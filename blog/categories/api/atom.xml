<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: api | Aurélien Hervé]]></title>
  <link href="http://aurelien-herve.com/blog/categories/api/atom.xml" rel="self"/>
  <link href="http://aurelien-herve.com/"/>
  <updated>2015-02-25T12:35:06+01:00</updated>
  <id>http://aurelien-herve.com/</id>
  <author>
    <name><![CDATA[A. Hervé]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Awesome low level caching for your Rails app]]></title>
    <link href="http://aurelien-herve.com/blog/2015/01/21/awesome-low-level-caching-for-your-rails-app/"/>
    <updated>2015-01-21T13:13:20+01:00</updated>
    <id>http://aurelien-herve.com/blog/2015/01/21/awesome-low-level-caching-for-your-rails-app</id>
    <content type="html"><![CDATA[<h3>Performant cache structure to save duplicate calculations</h3>

<p>Rubyist love the DRY moto (Don&rsquo;t Repeat Yourself). Here&rsquo;s how to implement a cache structure so that we Don&rsquo;t Calculate Twice.</p>

<p>What we want:</p>

<ul>
<li>Don&rsquo;t compute anything twice, until there is a good reason to think the result might change</li>
<li>Any change in the database should be immediatly visible to users (no caching for a few minutes, hoping things won&rsquo;t change too fast)</li>
<li>Don&rsquo;t compute anything that has not be requested by a user (<em>i.e.</em> don&rsquo;t pre-calculate everything )</li>
</ul>


<p>Sounds awesome, how do we proceed ?</p>

<!-- more -->


<h2>The best blog app ever</h2>

<p>Say we have a blogging platform where your users can write posts. For each post can be commented by the viewers, and each comment itself can be upvoted or downvoted.</p>

<p><img class="center" src="/images/cache_diag.png"></p>

<p>We could define an <em>interesting comment</em>  is a comment where the number of upvoters is higher than the number of downvoters, so it has a <code>comment.score &gt; 0</code>.</p>

<p>Now what about we extract the number of interesting comments a user generated through his/her posts ?</p>

<h3>Methods definitions without cache</h3>

<p>First, let&rsquo;s define a structure that will define <code>User</code>, <code>Post</code> and <code>Comment</code>:</p>

<p>```ruby app/models/comment.rb
class Comment
  include Mongoid::Document
  include Mongoid::Timestamps</p>

<p>  # the comment have a content
  field :content, type: String</p>

<p>  # stores the score for queries
  field :score, type: Integer</p>

<p>  # the comment belongs to a post
  belongs_to :post</p>

<p>  # the comment have upvoters
  has_and_belongs_to_many :upvoters  , class_name: &ldquo;User&rdquo;, inverse_of: &ldquo;liked_comments&rdquo;</p>

<p>  # the comment have downvoters
  has_and_belongs_to_many :downvoters, class_name: &ldquo;User&rdquo;, inverse_of: &ldquo;disliked_comments&rdquo;</p>

<p>  # score is computed, then stored at each save:
  before_save :set_score</p>

<p>  def set_score</p>

<pre><code>self.write_attributes(score: upvoter_ids.size - downvoter_ids.size)
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>```ruby app/models/post.rb
class Post
  include Mongoid::Document
  include Mongoid::Timestamps</p>

<p>  # the post belongs to its author
  belongs_to :author, class_name: &ldquo;User&rdquo;, inverse_of: :posts</p>

<p>  # the post content
  field :content, type: String</p>

<p>  # the post has many comments
  has_many :comments</p>

<p>  # How many interesting comments does it have?
  def interesting_comments_count</p>

<pre><code>comments.gt(score: 0).count #gt = greater than
</code></pre>

<p>  end
end
```</p>

<p>```ruby app/models/user.rb
class User
  include Mongoid::Document
  include Mongoid::Timestamps</p>

<p>  has_many :posts, class_name: &ldquo;Post&rdquo;, inverse_of: :author</p>

<p>  # the post score is the sum of all posts scores
  def interesting_comments_count</p>

<pre><code>posts.map(&amp;:interesting_comments_count).reduce(:+) #map/reduce rules
</code></pre>

<p>  end
end
```</p>

<h2>The <em>fastest</em> blog app ever</h2>

<p>Now that we have our structure working, let&rsquo;s add some cache to make this the fastest (and smartest) engine ever.</p>

<p>Rails has a nice tool for managing cache. You can either configure <code>Rails.cache</code> to use a <a href="http://redis.io/">redis</a> database, or keep the default parameters.</p>

<p>In particular, we can use <code>Rails.cache.fetch( key, expires_in: seconds) do ...</code> that will do the following:</p>

<ul>
<li>If a value is found at the given key, then return it</li>
<li>If no value is found (<em>i.e.</em> such key doesn&rsquo;t exist), then execute the block, returns its result, and store the result as the new value for key <code>key</code>.</li>
</ul>


<p>Let&rsquo;s use the cache to cache methods results at low level:
In <code>comment.rb</code> we add:
<code>ruby app/models/comment.rb
class Comment
  ...
  # this will update the `updated_at` key of our post
  belongs_to :post, touch: true
end
</code></p>

<p>This first addition will change the <code>post</code> timestamp each time a comment is upvoted or downvoted so that from the <code>post</code> model, we&rsquo;ll know something has changed.</p>

<p>```ruby app/models/post.rb
  def interesting_comments_count</p>

<pre><code># when was the last update ?
date_key = self.updated_at

# create unique key for each post, method, and timestamp
cache_key = "postInterestingCommentCount|#{id}|{date_key}"

# Fetch the value, or calculate it then store it into cache:
Rails.cache.fetch(cache_key, expires_in: 2.days) do 
  comments.gt(score: 0).count #gt = greater than
end
</code></pre>

<p>  end
```</p>

<p><strong>Explanations</strong>:</p>

<ul>
<li>First run: a key is created, the result is calculated and stored at the key address.</li>
<li>Another <code>interesting_comments_count</code> call happens. If no comment score has been updated, then the key will be the same, and the result will be presented without running any query. Fine</li>
<li>Someone upvote a comment. The post timestamp updates thanks to our <code>comment</code> callback. Thus, the <code>date_key</code> returns a different value. The computed <code>cache_key</code> changes, and we are now looking at a key address where no results exists yet. Back to step one.</li>
</ul>


<p> As a result of this, we can see that when a cache key becomes outdated, then it is not destroyed nor looked for: it is simply ignored and replaced by a new key that will be used until further change.</p>

<p>To avoid overloading your base, an expiration date is set, so that after a while, any key will simply be destroyed after a while.</p>

<p>Simple, isn&rsquo;t it ?</p>

<p>Now let&rsquo;s go a step further with the same idea in mind:</p>

<p>in our <code>Post definition</code>:
<code>ruby app/models/post.rb
class Post
  ...
  # adding touch: true will update the `updated_at` key of our user when the post is updated
  belongs_to :author, class_name: "User", inverse_of: :posts, touch: true
end
</code></p>

<p>in <code>User</code>:
```ruby app/models/user.rb
class User
  &hellip;
  def interesting_comments_count</p>

<pre><code>cache_timestamp = self.updated_at
cache_key = "userInterestingCommentCount|#{id}|#{cache_timestamp}"

Rails.cache.fetch(cache_key, expires_in: 2.days) do 
  posts.map(&amp;:interesting_comments_count).reduce(:+) 
end
</code></pre>

<p>  end
end
```</p>

<p>This additional step uses exactly the same strategy as before.</p>

<p>Now take a look at what would happen in real conditions.</p>

<ul>
<li>A user <code>u</code> has 10 posts.</li>
<li><strong><code>u.interesting_comments_count</code> is called:</strong>

<ul>
<li>A cache key is generated for each <code>Post</code> that belongs to <code>u</code></li>
<li>An additional cache key is generated for our user <code>u</code>.</li>
</ul>
</li>
<li><strong><code>u.interesting_comments_count</code> is called again:</strong>

<ul>
<li>The higher level cache key finds a result, and return. No db query is run.</li>
</ul>
</li>
<li>A comment is being upvoted

<ul>
<li>it touches the corresponding comment</li>
<li>the corresponding comment itself triggers a callback => the corresponding user is touched</li>
</ul>
</li>
<li><strong><code>u.interesting_comments_count</code> is called:</strong>

<ul>
<li>the user cache key is outdated and the method is run again.</li>
<li>For 9 of the 10 posts, the <code>post.interesting_comments_count</code> has an active cache key and the result is instantly returned</li>
<li>For the post that changed, the result is calculated, and returned while a new cache key is being generated.</li>
</ul>
</li>
<li>back to step 2</li>
</ul>


<p>If you&rsquo;re still with me here, then you&rsquo;ve probably seen how this cache structure allows to calculate <strong>exactly</strong> what is necessary, and <strong>only</strong> when required to do so.</p>

<p>How awesome is that ?</p>

<p><img class="center" src="/images/awesome.gif"></p>

<h3>Conclusion</h3>

<p>For most of the apis I write, I&rsquo;m using this trick quite extensively. It allows any user/developper to call any method without having to fear to trigger unnecessary long calculations.</p>

<p>I hope this was of some help, feel free to give your feedback or to ask any questions !</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Building an advanced api option parser for grape]]></title>
    <link href="http://aurelien-herve.com/blog/2014/10/14/advanced-api-option-parser-for-grape/"/>
    <updated>2014-10-14T09:52:35+02:00</updated>
    <id>http://aurelien-herve.com/blog/2014/10/14/advanced-api-option-parser-for-grape</id>
    <content type="html"><![CDATA[<p>When building an elaborated api, you might want your users to pass parameters in order to describe exactly what response they expect from the api.</p>

<p>For instance, it is useful to be able to do something as</p>

<p><code>ruby
GET '/users/:id', {users: {name: true}}  # =&gt; find a user and get his name only
GET '/users/:id', {users: {email: true, name: true}} # =&gt; find a user and get both his name and email
GET '/users/:id', {users: {email: true, name: true, posts: true}, post: {title: true}} # =&gt; find a user and get his name, his email, and all his posts titles
</code>
instead of presenting all of the model&rsquo;s attributes at each api call.</p>

<!-- more -->


<h2>1. Basic grape/entity usage</h2>

<p>At <a href="http://shapter.com">Shapter</a> we use the awesome <a href="https://github.com/intridea/grape">Grape</a> api framework, along with <a href="https://github.com/intridea/grape-entity">grape-entity</a>.</p>

<p>For instance, let&rsquo;s say we wan to build a route that finds and present a user:</p>

<p>```ruby AwesomeApp/entities/user.rb
module AwesomeApp
  module Entities</p>

<pre><code>module User &lt; Grape::Entity
  expose :id
  expose :name
  expose :email
end
</code></pre>

<p>  end
end
```</p>

<p>```ruby api/users.rb
namespace :users do  # prefix routes with &lsquo;users/&rsquo;
  desc &ldquo;get a user&rdquo; # describe your method for the documentation
  params do</p>

<pre><code>requires "user_id", desc: "id of the user" # requires a user_id to be passed
</code></pre>

<p>  end
  get &lsquo;:user_id&rsquo; do  # this will get the params[:user_id] from the url</p>

<pre><code>user = User.find(params[:user_id]) || error!('user not found',404) # find the user
present user, with: AwesomeApp::Entities::User  # use grape-entity to present the model
</code></pre>

<p>  end
end
```</p>

<p>This setup will create a <code>/users/:id/</code> route that returns a user in a hash of the form <code>{id: 123, name: "John Doe", email: "foo@bar.com"}</code></p>

<h2>2. With a bit of optimization</h2>

<p>If your api is to grow more complex, the number of exposed attributes can quickly increase, and with it the size of the json hash the api sends. However you do not want all of the <code>User</code>&rsquo;s attributes to be return each time you call your route.</p>

<p>To avoid unnecessary overload, you can build an option parser that allow the api-user to describe the type of response he&rsquo;s expecting.</p>

<h4>Add conditional exposures to your entity</h4>

<p>First we tell entity to expose attributes only when asked to:</p>

<p>```ruby AwesomeApp/entities/user.rb
module AwesomeApp
  module Entities</p>

<pre><code>module User &lt; Grape::Entity
  expose :id # always expose the id
  expose :name, if: lambda{ |user,options| options[:entity_options]["user"][:name]}   #conditional exposure
  expose :email, if: lambda{ |user,options| options[:entity_options]["user"][:email]} #conditional exposure
end
</code></pre>

<p>  end
end
```</p>

<h4>create a helper to parse the options</h4>

<p>Next, we create a helper that will read <code>params</code> to avoid tedious code duplication:</p>

<p>```ruby AwesomeApp/Helpers/OptionsHelper</p>

<h1>white-list params[:entities][&lt;some_model>], and create empty hashes if needed:</h1>

<p>def entity_options
  {</p>

<pre><code>"user" =&gt; (params[:entities]["user"] rescue nil) || {},
"post" =&gt; (params[:entities]["post"] rescue nil) || {},
</code></pre>

<p>  }
end
```</p>

<h4>pass the options hash to Grape::Entity</h4>

<p>Finally, we need to connect everything in the api method description:</p>

<p>```ruby api/users.rb
helpers AwesomeApp::Helpers::OptionsHelper #include the helper</p>

<p>namespace :users do</p>

<pre><code>...
present user, with: AwesomeApp::Entities::User, entity_options: entity_options #simple call entity_options
</code></pre>

<p>end
```</p>

<h4>Profit</h4>

<p>And <em>Voila</em> !</p>

<p>Now your api-users can efficiently call the routes to get the attributes they want:
<code>ruby
GET '/users/:id', {users: {name: true}}  # =&gt; find a user and get his name only
GET '/users/:id', {users: {email: true, name: true}} # =&gt; find a user and get both his name and email
</code></p>

<h3>Bonus: it works with nested model exposures !</h3>

<p>Note that this system supports nested models exposures. For instance, if you want to get a user, and a list of his post ids and titles, then the following will work like a charm:</p>

<p>```ruby AwesomeApp/entities/user.rb</p>

<h1>AwesomeApp/entities/user.rb</h1>

<p>module AwesomeApp
  module Entities</p>

<pre><code>module User &lt; Grape::Entity
  expose :id # always expose the id
  expose :name, if: lambda{ |user,options| options[:entity_options]["user"][:name]}   #conditional exposure
  expose :email, if: lambda{ |user,options| options[:entity_options]["user"][:email]} #conditional exposure
  expose :posts, using: AwesomeApp::Entities::Post, if: lambda{ |user,options| options[:entity_options]["user"][:posts]} # present user's posts
end
</code></pre>

<p>  end
end</p>

<h1>AwesomeApp/Entities/post.rb</h1>

<p>module AwesomeApp
  module Entities</p>

<pre><code>module Post &lt; Grape::Entity
  expose :id # always expose the id
  expose :title, if: lambda{ |post,options| options[:entity_options]["post"][:name]}   #conditional exposure
  expose :content, if: lambda{ |post,options| options[:entity_options]["post"][:email]} #conditional exposure
end
</code></pre>

<p>  end
end
```</p>

<p>Without changing anything to the api, you can now call
<code>ruby
GET '/users/123', entity_options: { user: {name: true, posts: true}, post: {title: true}}
</code>
To tell the api you want to include the user&rsquo;s post ids in the response. You will then get something that looks like
```
{
  id: 123,
  name: &ldquo;John Doe&rdquo;,
  posts: [</p>

<pre><code>{id: 456, title: "first post" }, #post content is not asked for, therefore not sent
{id: 789, title: "second post" },
</code></pre>

<p>  ]
}
```</p>
]]></content>
  </entry>
  
</feed>
