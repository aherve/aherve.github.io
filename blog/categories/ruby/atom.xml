<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | Aurélien Hervé]]></title>
  <link href="http://aurelien-herve.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://aurelien-herve.com/"/>
  <updated>2014-10-15T19:51:48+02:00</updated>
  <id>http://aurelien-herve.com/</id>
  <author>
    <name><![CDATA[A. Hervé]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Building an advanced api option parser for grape]]></title>
    <link href="http://aurelien-herve.com/blog/2014/10/14/advanced-api-option-parser-for-grape/"/>
    <updated>2014-10-14T09:52:35+02:00</updated>
    <id>http://aurelien-herve.com/blog/2014/10/14/advanced-api-option-parser-for-grape</id>
    <content type="html"><![CDATA[<p>When building an elaborated api, you might want your users to pass parameters in order to describe exactly what response they expect from the api.</p>

<p>For instance, it is useful to be able to do something as</p>

<p><code>ruby
GET '/users/:id', {users: {name: true}}  # =&gt; find a user and get his name only
GET '/users/:id', {users: {email: true, name: true}} # =&gt; find a user and get both his name and email
GET '/users/:id', {users: {email: true, name: true, posts: true}, post: {title: true}} # =&gt; find a user and get his name, his email, and all his posts titles
</code>
instead of presenting all of the model&rsquo;s attributes at each api call.</p>

<!-- more -->


<h2>1. Basic grape/entity usage</h2>

<p>At <a href="http://shapter.com">Shapter</a> we use the awesome <a href="https://github.com/intridea/grape">Grape</a> api framework, along with <a href="https://github.com/intridea/grape-entity">grape-entity</a>.</p>

<p>For instance, let&rsquo;s say we wan to build a route that finds and present a user:</p>

<p>```ruby AwesomeApp/entities/user.rb
module AwesomeApp
  module Entities</p>

<pre><code>module User &lt; Grape::Entity
  expose :id
  expose :name
  expose :email
end
</code></pre>

<p>  end
end
```</p>

<p>```ruby api/users.rb
namespace :users do  # prefix routes with &lsquo;users/&rsquo;
  desc &ldquo;get a user&rdquo; # describe your method for the documentation
  params do</p>

<pre><code>requires "user_id", desc: "id of the user" # requires a user_id to be passed
</code></pre>

<p>  end
  get &lsquo;:user_id&rsquo; do  # this will get the params[:user_id] from the url</p>

<pre><code>user = User.find(params[:user_id]) || error!('user not found',404) # find the user
present user, with: AwesomeApp::Entities::User  # use grape-entity to present the model
</code></pre>

<p>  end
end
```</p>

<p>This setup will create a <code>/users/:id/</code> route that returns a user in a hash of the form <code>{id: 123, name: "John Doe", email: "foo@bar.com"}</code></p>

<h2>2. With a bit of optimization</h2>

<p>If your api is to grow more complex, the number of exposed attributes can quickly increase, and with it the size of the json hash the api sends. However you do not want all of the <code>User</code>&rsquo;s attributes to be return each time you call your route.</p>

<p>To avoid unnecessary overload, you can build an option parser that allow the api-user to describe the type of response he&rsquo;s expecting.</p>

<h4>Add conditional exposures to your entity</h4>

<p>First we tell entity to expose attributes only when asked to:</p>

<p>```ruby AwesomeApp/entities/user.rb
module AwesomeApp
  module Entities</p>

<pre><code>module User &lt; Grape::Entity
  expose :id # always expose the id
  expose :name, if: lambda{ |user,options| options[:entity_options]["user"][:name]}   #conditional exposure
  expose :email, if: lambda{ |user,options| options[:entity_options]["user"][:email]} #conditional exposure
end
</code></pre>

<p>  end
end
```</p>

<h4>create a helper to parse the options</h4>

<p>Next, we create a helper that will read <code>params</code> to avoid tedious code duplication:</p>

<p>```ruby AwesomeApp/Helpers/OptionsHelper</p>

<h1>white-list params[:entities][&lt;some_model>], and create empty hashes if needed:</h1>

<p>def entity_options
  {</p>

<pre><code>"user" =&gt; (params[:entities]["user"] rescue nil) || {},
"post" =&gt; (params[:entities]["post"] rescue nil) || {},
</code></pre>

<p>  }
end
```</p>

<h4>pass the options hash to Grape::Entity</h4>

<p>Finally, we need to connect everything in the api method description:</p>

<p>```ruby api/users.rb
helpers AwesomeApp::Helpers::OptionsHelper #include the helper</p>

<p>namespace :users do</p>

<pre><code>...
present user, with: AwesomeApp::Entities::User, entity_options: entity_options #simple call entity_options
</code></pre>

<p>end
```</p>

<h4>Profit</h4>

<p>And <em>Voila</em> !</p>

<p>Now your api-users can efficiently call the routes to get the attributes they want:
<code>ruby
GET '/users/:id', {users: {name: true}}  # =&gt; find a user and get his name only
GET '/users/:id', {users: {email: true, name: true}} # =&gt; find a user and get both his name and email
</code></p>

<h3>Bonus: it works with nested model exposures !</h3>

<p>Note that this system supports nested models exposures. For instance, if you want to get a user, and a list of his post ids and titles, then the following will work like a charm:</p>

<p>```ruby AwesomeApp/entities/user.rb</p>

<h1>AwesomeApp/entities/user.rb</h1>

<p>module AwesomeApp
  module Entities</p>

<pre><code>module User &lt; Grape::Entity
  expose :id # always expose the id
  expose :name, if: lambda{ |user,options| options[:entity_options]["user"][:name]}   #conditional exposure
  expose :email, if: lambda{ |user,options| options[:entity_options]["user"][:email]} #conditional exposure
  expose :posts, using: AwesomeApp::Entities::Post, if: lambda{ |user,options| options[:entity_options]["user"][:posts]} # present user's posts
end
</code></pre>

<p>  end
end</p>

<h1>AwesomeApp/Entities/post.rb</h1>

<p>module AwesomeApp
  module Entities</p>

<pre><code>module Post &lt; Grape::Entity
  expose :id # always expose the id
  expose :title, if: lambda{ |post,options| options[:entity_options]["post"][:name]}   #conditional exposure
  expose :content, if: lambda{ |post,options| options[:entity_options]["post"][:email]} #conditional exposure
end
</code></pre>

<p>  end
end
```</p>

<p>Without changing anything to the api, you can now call
<code>ruby
GET '/users/123', entity_options: { user: {name: true, posts: true}, post: {title: true}}
</code>
To tell the api you want to include the user&rsquo;s post ids in the response. You will then get something that looks like
```
{
  id: 123,
  name: &ldquo;John Doe&rdquo;,
  posts: [</p>

<pre><code>{id: 456, title: "first post" }, #post content is not asked for, therefore not sent
{id: 789, title: "second post" },
</code></pre>

<p>  ]
}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Having fun with functional programming in ruby]]></title>
    <link href="http://aurelien-herve.com/blog/2014/02/27/some-cool-functional-programming-with-ruby/"/>
    <updated>2014-02-27T21:51:46+01:00</updated>
    <id>http://aurelien-herve.com/blog/2014/02/27/some-cool-functional-programming-with-ruby</id>
    <content type="html"><![CDATA[<p>Today we&rsquo;re going to play around with functional programming. Yay !</p>

<ul>
<li><em>Ok, what&rsquo;s that exactly ?</em></li>
</ul>


<p>Wikipedia says it pretty much:</p>

<blockquote><p>functional programming is a programming paradigm, a style of building the structure and elements of computer programs, that treats computation as the evaluation of mathematical functions and avoids state and mutable data.</p></blockquote>

<ul>
<li>Alright, now let&rsquo;s have some fun with functional programming style, and of course, let&rsquo;s do that with ruby :)</li>
</ul>


<p>In this post we&rsquo;re going to manipulate some (high order) functions, and build a derivative operator in a functional style.</p>

<!-- more -->


<h3>Level 1 : some basic functions</h3>

<p>In ruby you can define a <em>lambda</em> operator, that is an anonymous function that reads exactly as a mathematician would define it. For instance,
<code>ruby
square = -&gt; x { x*x} #or its equivalent notation: square = lambda { |x| x*x }
plus_one = -&gt; x { x+1}
</code>
defines a function that, when given an argument <code>x</code>, returns <code>x*x</code>.</p>

<p>We can call it and see the result :
<code>ruby
square.(2) #=&gt; 4
plus_one.(2) #=&gt; 3
</code></p>

<p>More interestingly, higher order function can be defined, whose purpose is to manipulate other functions.</p>

<p>For instance, let&rsquo;s define some basic operators <code>minus</code>,<code>mult</code>,<code>div</code> that can respectively add, subtract, multiply or divide functions altogether.</p>

<p>Note that we want <code>new_function = minus.(f,g)</code> to return a function.
Rather than describing how to subtract two values, we want to define what <code>f -g</code> means when both f and g are functions.</p>

<p><code>ruby
minus = -&gt; f,g { -&gt; x { f.(x) - g.(x) } }
div   = -&gt; f,g { -&gt; x { f.(x) / g.(x) } }
mult  = -&gt; f,g { -&gt; x { f.(x) * g.(x) } }
</code></p>

<p>Does that works ? With the previously defined functions:</p>

<p><code>ruby
my_fancy_func = minus.(square,plus_one) # defining a new function
my_fancy_func.(3) #=&gt; 5 = 3*3 - ( 3 + 1)
</code></p>

<p>Sweet.</p>

<ul>
<li><em>Allright, but how is that really fancy?</em></li>
</ul>


<p>Well, let&rsquo;s take our trip to a next step:</p>

<h3>Level 2 : I can haz derivative ?</h3>

<p><em>Hey, I know an operator that works on functions : the derivative operator. How about we build one ?</em></p>

<p>Alright. Let&rsquo;s build a derivative operator. That is, a function that takes a function as an argument, and return another function: its derivate.</p>

<p>The derivative of a function at some point <em>x</em> can be obtained by evaluating
<img src="/images/derivative.gif" alt="derivative" />, <em>i.e.</em> the limit when epsilon &ndash;> 0 of a derivative scheme based on f at point x.</p>

<p>Here&rsquo;s the plan :</p>

<ul>
<li>Define a limit operator</li>
<li>define a derivative scheme</li>
<li>define the derivative operator as the limit of the derivative scheme of a function</li>
<li>Since we&rsquo;re at it, define any <em>nth derivative operator</em> : We should be able to derivate n times any function.</li>
<li>Profit and use it on <em>any function</em></li>
</ul>


<p>For the sake of clarity, let&rsquo;s begin with a simplified version, and assume that <code>epsilon = 1e-3</code> is low enough to approximate the limit of our derivative scheme.</p>

<p>Once we&rsquo;re more comfortable with the concepts, we&rsquo;ll get rid of this assumption and implement a true derivative operator.</p>

<p>```ruby
derivative = &ndash;> f { # we take a function as argument
  &ndash;> x { # the function takes a real x as argument</p>

<pre><code>( f.(x+1e-3) - f.(x-1e-3) ) / ( 2e-3 ) # apply the scheme
</code></pre>

<p>  }
}</p>

<h1>Let&rsquo;s try:</h1>

<p>derivative_of_square = derivative.(square)  => #&lt;Proc:0x00000001b7c270@(irb):24 (lambda)> . Yay, a new function !</p>

<h1>Can we use it ?</h1>

<p>square.(3) # => 9
derivative_of_square.(3) #  => 5.999999999999339 ~ 2*3. Cool !
```</p>

<p><em>Sooo&hellip; can I derivate twice ?</em></p>

<p>Yup. Simply get the derivative of the derivative :
<code>ruby
second_derivative_of_square = derivative.( derivative.(square) ) # this should be a constant function that return 2
second_derivative_of_square.(2) #=&gt; 1.999999999946489
second_derivative_of_square.(3) #=&gt; 2.000000000279556
</code></p>

<p><em>Sooooooo&hellip; can I derivate n times ?</em></p>

<p>Yup. Although we don&rsquo;t want to create thousands of <code>third_derivative</code>,<code>forth_derivative</code>&hellip;etc, right ?</p>

<p>Let&rsquo;s go one order higher and define the <em>nth derivative operator</em></p>

<p>Since we can derivate a function, and we want to do it n times, what we miss is simply a <code>n-times combinator</code>. For example, <code>n_times.(f).(2)</code> should return <code>x -&gt; f(f(x))</code> regardless of what <code>f</code> and <code>x</code> are.</p>

<p>Shall we do it recursively ?
<code>ruby
n_times = -&gt; n,f {
  n == 1 ? f : -&gt; x { f.(n_times.(n-1,f).(x))}
}
</code></p>

<p><strong>Explanation</strong> :</p>

<ul>
<li>if <em>n = 1</em> then we want f. so return f. So far so good, <code>n_times(1,f) = f</code></li>
<li>If <em>n = 2</em>, then we want f(f) = f( n_times.(1,f) )</li>
<li>If <em>n = 3</em>, then we want f(f(f)) = f( n_times.(2,f) )</li>
</ul>


<p>&hellip;etc. Get it ?</p>

<p><em>Wait&hellip; that&rsquo;s all ? Where&rsquo;s my nth derivative ?</em></p>

<p>Now it&rsquo;s quite easy to derivate n times :</p>

<p><code>ruby
nth_derivator = -&gt; n {
  n_times.(n,derivate)
}
</code>
This <code>nth_derivator</code> will take <code>n</code> as an argument, and derivate n times whatever we decide to pass to it.</p>

<p>Let&rsquo;s play with it!
```ruby
derivative_of_square = nth_derivator.(1).(square) #derivate one time
second_derivative_of_square = nth_derivator.(2).(square) #derivate two times
third_derivative_of_square = nth_derivator.(3).(square) #derivate three times</p>

<p>p derivative_of_square.(3) # => 5.999999999999339
p second_derivative_of_square.(3) # => 2.000000000279556
p third_derivative_of_square.(3) # => 0.0
```</p>

<p><em>That&rsquo;s cool ! but those are approximations, right ? we never actually calculated the limit</em></p>

<p>Yet.</p>

<h3>Level 3 : More functional, and a true limit operator</h3>

<p>Now that we have a better feel for it (have we?), let&rsquo;s refactor our derivative operator so that it is <em>actually</em> defined as a limit. And hey, let&rsquo;s parametrize the precision that we want since we&rsquo;re at it.</p>

<p><img class="right" src="/images/party_over.gif" title="" ></p>

<p>First, let&rsquo;s write a bunch of tools that are going to be useful:
```ruby
minus = &ndash;> f,g { &ndash;> x { f.(x) &ndash; g.(x) } } # f &ndash; g
div   = &ndash;> f,g { &ndash;> x { f.(x) / g.(x) } } # f / g
mult  = &ndash;> f,g { &ndash;> x { f.(x) * g.(x) } } # f * g
norm  = &ndash;> f   { &ndash;> x { f.(x).abs}} # absolute value
const = &ndash;> const { &ndash;> x { const} } # That&rsquo;s right, the constant function !</p>

<h1>You should recognize these:</h1>

<p>plus_eps = &ndash;> eps { &ndash;> f { &ndash;> x { f.(x+eps) } } }
min_eps  = &ndash;> eps { &ndash;> f { &ndash;> x { f.(x-eps) } } }</p>

<h1>is f &lt; g ?</h1>

<p>inf = &ndash;> f,g { &ndash;> x { f.(x) &lt; g.(x) } }
```</p>

<p>Now the limit function. Here we are going to define a function, that actually implement the following (naive) algorithm:</p>

<ul>
<li>variables : a function <code>f</code>, a starting epsilon <code>eps</code>, and a threshold <code>tres</code></li>
<li><ol>
<li>Evaluate y = ||f(x + epsilon/2) &ndash; f(x + epsilon) ||</li>
</ol>
</li>
<li><ol>
<li>if y &lt; tres, then we are converged, and lowering epsilon wouldn&rsquo;t change the result much. Return f(x+epsilon).</li>
</ol>
</li>
<li><ol>
<li>else, reduce epsilon and try again (i.e. go to 1.)</li>
</ol>
</li>
</ul>


<p>Obviously, this algorithm is quite simple, and will only work when dealing with smooth, continuous, and gracious functions.</p>

<p>Ready ?
```ruby
lim = &ndash;> f,eps,tres {
  &ndash;> x {</p>

<pre><code>inf.(
  norm.(
    minus.(
      plus_eps.(eps/2.0).(f),
      plus_eps.(eps).(f)
    )
  ), const.(tres) ).(x) ? plus_eps.(eps).(f).(x) : lim.(f,eps/2.0,tres).(x)
</code></pre>

<p>  }
}</p>

<h1>Does it even work ?</h1>

<p>lim.(square,1,1).(2) #=> 5.0625 wut ?
lim.(square,1,1e-2).(2) #=> 4.0156402587890625 Ah. Better
lim.(square,1,1e-16).(2) #=> 4.0 How nice !
```</p>

<p>Now we&rsquo;re getting close ! Let&rsquo;s refactor our derivative operator in a more appropriate way and get our final derivative operator:</p>

<p>```ruby</p>

<h1>derivative_scheme.(f).(x) shall be a function of epsilon</h1>

<p>derivative_sheme = &ndash;> f {
  &ndash;> x {</p>

<pre><code>-&gt; eps {
  div.( minus.(plus_eps.(eps).(f), min_eps.(eps).(f) ), mult.(const.(2), const.(eps))).(x)
}
</code></pre>

<p>  }
}</p>

<h1>And the derivative operator:</h1>

<h1>Let&rsquo;s fix the treshold at tres = 1e-16</h1>

<p>derivate = &ndash;> f {
  &ndash;> x {</p>

<pre><code>lim.(derivative_sheme.(f).(x),1,1e-16).(0) # limit of the derivative scheme of f(x), taken at epsilon = 0
</code></pre>

<p>  }
}</p>

<h1>Isn&rsquo;t that fancy ? We juste define the derivative operator</h1>

<h1>exactly as the limit of (f(x + e) &ndash; f(x &ndash; e))/(2e) when epsilon &ndash;> 0</h1>

<p>```</p>

<h3>Summary</h3>

<p>Here&rsquo;s a full code of what we implemented <a href="/assets/aherves_blog_ruby_functional.rb">(download it)</a></p>

<p>```ruby</p>

<h1>!/usr/bin/env ruby</h1>

<h1>Our fancy function. Could be exactly anything</h1>

<p>square = &ndash;> x { x*x}</p>

<h1>some tools</h1>

<p>minus = &ndash;> f,g { &ndash;> x { f.(x) &ndash; g.(x) } }
div   = &ndash;> f,g { &ndash;> x { f.(x) / g.(x) } }
mult  = &ndash;> f,g { &ndash;> x { f.(x) * g.(x) } }
norm  = &ndash;> f   { &ndash;> x { f.(x).abs}}
const = &ndash;> const { &ndash;> x { const} }</p>

<p>plus_eps = &ndash;> eps { &ndash;> f { &ndash;> x { f.(x+eps) } } }
min_eps  = &ndash;> eps { &ndash;> f { &ndash;> x { f.(x-eps) } } }</p>

<p>inf = &ndash;> f,g { &ndash;> x { f.(x) &lt; g.(x) } }</p>

<h1>The limit operator</h1>

<p>lim = &ndash;> f,eps,prec {
   &ndash;> x {</p>

<pre><code>inf.(norm.(minus.(plus_eps.(eps/2.0).(f), plus_eps.(eps).(f))) , const.(prec) ).(x) ? plus_eps.(eps).(f).(x) : lim.(f,eps/2.0,prec).(x)
</code></pre>

<p>  }
}</p>

<h1>The derivative scheme</h1>

<p>derivative_sheme = &ndash;> f {
  &ndash;> x {
  &ndash;> eps {
  div.( minus.(plus_eps.(eps).(f), min_eps.(eps).(f) ), mult.(const.(2), const.(eps))).(x)
}
}
}</p>

<h1>The derivative operator at precision 1e-16 is the limit of the derivative scheme</h1>

<p>derivate = &ndash;> f{
  &ndash;> x {
  lim.(derivative_sheme.(f).(x),1,1e-16).(0)
}
}</p>

<h1>call any function n times</h1>

<p>n_times = &ndash;> n,f {
  n == 1 ? f : &ndash;> x { f.(n_times.(n-1,f).(x))}
}</p>

<h1>an nth derivator is a derivator called n times:</h1>

<p>nth_derivator = &ndash;> n {
  n_times.(n,derivate)
}</p>

<p>p nth_derivator.(1).(square).(3) # => 6 =  2*(3)
p nth_derivator.(2).(square).(3) # => 2 =  constant(2)
p nth_derivator.(3).(square).(3) # => 0 = constant(0)</p>

<p>logarithm = &ndash;> x { Math.log(x) }
p nth_derivator.(1).(logarithm).(3) #=> 0.3333333333430346 ~ 1/3 I can derivate whatever I want !
```</p>

<p>Well that&rsquo;s all, hope you enjoyed reading this (at least) as much as I enjoyed writing it. Feel free to drop some comments, suggest anything, c orrect some code (or my english ) :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to create a gem structure with rspec and code coverage]]></title>
    <link href="http://aurelien-herve.com/blog/2014/02/15/create-a-gem-structure-with-rspec-and-code-coverage/"/>
    <updated>2014-02-15T21:59:36+01:00</updated>
    <id>http://aurelien-herve.com/blog/2014/02/15/create-a-gem-structure-with-rspec-and-code-coverage</id>
    <content type="html"><![CDATA[<h3>tl;dr</h3>

<p>This is a step-by-step tutorial for creating a gem structure, along with some unit tests and code coverage.</p>

<!-- more -->


<h2>1. Bundle: create the structure</h2>

<ul>
<li>Create the directories using bundler:
<code>
$ bundle gem my_fancy_gem
create  my_fancy_gem/Gemfile
create  my_fancy_gem/Rakefile
create  my_fancy_gem/LICENSE.txt
create  my_fancy_gem/README.md
create  my_fancy_gem/.gitignore
create  my_fancy_gem/my_fancy_gem.gemspec
create  my_fancy_gem/lib/my_fancy_gem.rb
create  my_fancy_gem/lib/my_fancy_gem/version.rb
Initializing git repo in &lt;wherever you are&gt;/my_fancy_gem
</code></li>
<li>fill the gem description in <code>my_fancy_gem.gemspec</code></li>
</ul>


<h2>2. Configure rspec</h2>

<ul>
<li><p>add rspec to the dependencies in <code>my_fancy_gem.gemspec</code>:
<code>ruby my_fancy_gem.gemspec
...
spec.add_development_dependency "rake"
spec.add_development_dependency "rspec"
end
</code>
and make sure you install it:
  $ bundle</p></li>
<li><p>create <code>spec/spec_helper.rb</code> file:
<code>ruby spec/spec_helper.rb
require 'rspec'
require 'my_fancy_gem'
</code></p></li>
<li><p>I like it better with colors. In <code>.rspec</code>:
<code>ruby .rspec
--color
</code></p></li>
</ul>


<h3>Now let&rsquo;s create some method and test it</h3>

<p>Let&rsquo;s write a hello world method with TDD</p>

<ul>
<li>in <code>spec/my_fancy_gem_spec.rb</code>
<code>ruby spec/my_fancy_gem_spec.rb
require 'spec_helper'
describe SmartadCollector do
it "should greet" do
  SmartadCollector::greet.should == "Hello, world!"
end
end
</code></li>
<li>Proudly watch the test failing by running <code>rspec</code></li>
<li>Now let&rsquo;s write the actual method: <code>lib/my_fancy_gem_spec.rb</code>
```ruby lib/my_fancy_gem.rb
require &ldquo;my_fancy_gem/version&rdquo;</li>
</ul>


<p>module MyFancyGem
  def self.greet</p>

<pre><code>"Hello, world!"
</code></pre>

<p>  end
end
```
and (even more) proudly watch the test pass:</p>

<pre><code>$ rspec #=&gt; 1 example, 0 failures
</code></pre>

<h2>3. Adding code coverage tools</h2>

<p><a href="https://github.com/colszowka/simplecov">SimpleCov</a> to get code coverage:</p>

<ul>
<li>add <code>spec.add_development_dependency "simplecov"</code> in <code>my_fancy_gem_spec.gemspec</code>.</li>
<li><p><code>$ bundle install</code> to install the simple cov gem</p></li>
<li><p>create a <code>.simplecov</code> file:
<code>ruby .simplecov
SimpleCov.start do
add_group "lib", "lib"
end
</code></p></li>
<li><p>add it to rspec: <code>spec/spec_helper.rb</code>:
<code>ruby spec/spec_helper.rb
require 'rspec'
require 'simplecov'
require 'my_fancy_gem_spec'
</code>
Please note that the <code>require 'simplecov'</code> has to be added before <code>require 'my_fancy_gem_spec'</code>.</p></li>
</ul>


<p>Now running <code>$ rspec</code> will output a report on code coverage, as well as a <code>coverage</code> directory. You can browse <code>coverage/index.html</code> to view the detailed report.</p>
]]></content>
  </entry>
  
</feed>
