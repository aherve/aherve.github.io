<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | Aurélien Hervé]]></title>
  <link href="http://aurelien-herve.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://aurelien-herve.com/"/>
  <updated>2015-01-14T18:58:11+01:00</updated>
  <id>http://aurelien-herve.com/</id>
  <author>
    <name><![CDATA[A. Hervé]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Big data with hadoop stream and ruby (and not even one line of java)]]></title>
    <link href="http://aurelien-herve.com/blog/2015/01/14/big-data-with-hadoop-stream-and-ruby/"/>
    <updated>2015-01-14T13:42:09+01:00</updated>
    <id>http://aurelien-herve.com/blog/2015/01/14/big-data-with-hadoop-stream-and-ruby</id>
    <content type="html"><![CDATA[<h3>Objective:</h3>

<p>In this tuto I&rsquo;ll show you how to process billions of data with minimal efforts and code with elastic mapreduce and hadoop-stream. Our list to Santa is :</p>

<ul>
<li>I want to process an unknown amount of data in a scalable, custom way</li>
<li>The same code can be run locally and remotely, so I can debug or process any amount of data without changing anything</li>
<li>I should be able to use any language I like, and this does not especially have to be java. In this example I&rsquo;ll be using ruby because it&rsquo;s awesome. Simply translate this tuto to python, perl, php or anything you want, it&rsquo;ll still work.</li>
</ul>


<!-- more -->


<h2>1. Let&rsquo;s play a game</h2>

<p>Let&rsquo;s suppose we are running a huge gaming platform. As the brand new data scientist, we&rsquo;re asked to perform some simple stats on our users.</p>

<p>For the sake of the example, let&rsquo;s compute any user&rsquo;s average ranking, per type of played games.</p>

<p>From the platform logs we have to kind of files:</p>

<ul>
<li>a <code>GameLog</code> file describes the type of game, the date, and a game id</li>
<li>a <code>PlayerLog</code> file describes how a player scored a game. It contains the game id, the player id, and the player score.</li>
</ul>


<p>This looks like</p>

<p><code>ruby PlayerLog
PlayerId    Score    GameId    
1           1       1         
1           2       2         
2           0       1         
2           5       2         
</code></p>

<p><code>ruby GameLog
GameId    Type
1         chess
2         go   
</code></p>

<p>Our files are tab separated (tsv) format, and stored on an amazon <a href="https://aws.amazon.com/s3/">aws s3</a> bucket.</p>

<h4>Expected output:</h4>

<p><code>ruby Output
Player_id    GameType    AverageRank
1            chess       1
1            go          2
2            chess       2
2            go          1
</code></p>

<h2>2. Do this with style !</h2>

<p>We are going to solve this algorithm with mapreduce. Map/reduce is a programming paradigm that will allow you to <em>horizontally scale</em> the program execution. This means the more parallel servers you get, the more efficient you will be. Obviously within a reasonable range, mounting 300 servers to process 10 lines of data doesn&rsquo;t look like a good idea..</p>

<p>In addition to be scalable, I really find a map/reduce reduces the amount of code, increases claricity, and should thus be used even for moderate amount of datas.</p>

<p><strong>Bonus:</strong> We&rsquo;ll be able to run our code both locally for quick tests, and remotely for heavy processing \o/</p>

<h4>The approach</h4>

<p>Before entering in the details, here is what we are going to do:</p>

<ul>
<li>map the raw data and extract useful information (map)</li>
<li>group the data by <code>game_id</code> key (sort)</li>
<li>compute each player rank for each game (reduce1)</li>
<li>group the data by (player,game_type) couples (sort)</li>
<li>for each (player/game_type) couple, compute the average rank (reduce2)</li>
</ul>


<p>Our steps hence consists in a <em>map &ndash;> reduce &ndash;> reduce</em> procedure. If we think of a second mapper which is identity, then we have two <code>map-&gt;reduce</code> steps</p>

<p>As we plan to use hadoop-stream, the only things we need are three script files that will represent our mapper, and reducers. Each file will consist of a simple script that will &ldquo;eat&rdquo; data via <code>STDIN</code>, and output something to <code>STDOUT</code>.
Again, I&rsquo;m using ruby as an example here. If you&rsquo;re more comfortable with any other language, then please use it, as long as it knows <code>STDIN</code> and <code>STDOUT</code> !</p>

<p>Thanks to Hadoop, we won&rsquo;t have to take care of the sort steps, the data redundency management, the possible server crashes, and plenty of boring stuff. How nice is that ?</p>

<h3>2.1. first mapper</h3>

<p>The first mapper&rsquo;s role will be to &ldquo;eat&rdquo; raw data with absolutely no context, nor any knowledge of what&rsquo;s happening elsewhere (<em>i.e.</em> on other potential workers). It is very important to note that there is absolutely no relation between two consecutive lines that a mapper receives.
For instance, some mapper could receive the first line of the first log, then the 10th line of another log file, then the 2nd line of the first log&hellip;etc</p>

<p>```ruby map1.rb</p>

<h1>!/usr/bin/env ruby</h1>

<p>class Mapper</p>

<p>  # initialize a mapper with raw data.
  def initialize(line)</p>

<pre><code># chomp will remove endline characters
# split will split the line for every tab character \t
# strip will remove whitespaces at begining and end of every words
@data = line.chomp.split("\t").map(&amp;:strip)
</code></pre>

<p>  end</p>

<p>  # this &ldquo;switch&rdquo; will determine if we are reading a GameLog or a UserLog line
  # in our example, it is sufficient to look whether @data has 2, or 3 values
  # for more complex cases, I&rsquo;m sure you&rsquo;ll always find something ;)
  def log_type</p>

<pre><code>@log_type ||= if @data.size == 2
            :game_log
          else
            :player_log
          end
</code></pre>

<p>  end</p>

<p>  def game_log_output</p>

<pre><code>game_id   = @data[0]
game_type = @data[1]

[game_id, log_type, game_type].join("\t")
</code></pre>

<p>  end</p>

<p>  def player_log_output</p>

<pre><code>player_id = @data[0]
score     = @data[1]
game_id   = @data[2]

[game_id, log_type, player_id, score].join("\t")
</code></pre>

<p>  end</p>

<p>  # the mapper result
  def output</p>

<pre><code>return game_log_output if log_type == :game_log
return player_log_output
</code></pre>

<p>  end</p>

<p>  # the Map! class method
  def self.map!(line)</p>

<pre><code>puts Mapper.new(line).output
</code></pre>

<p>  end</p>

<p>end</p>

<p>ARGF.each do |line|
  Mapper.map!(line) unless line.chomp.empty? # map every non-empty line with our mapper
end
```</p>

<p>As you can see, this mapper will always output the <code>game_id</code> as first key. Then, regarding of the log type, it will either output informations about the player, or the game.</p>

<p>You can run locally your mapper by simply running <code>cat datain/* | map1.rb</code>, whitch outputs something like</p>

<p><code>ruby
1 player_log  1 1
2 player_log  1 2
1 player_log  2 0
2 player_log  2 5
1 game_log  chess
2 game_log  go
</code></p>

<h3>2.2 first sort</h3>

<p>I feel like this step should be explained even if it does not require any work. What will be happening here is that hadoop will take care of our first outputed results.
By default, it will split using the <code>tab</code> character, and will assign a single reducer instance for each key.
Furthermore, it will garanty that a reducer will see &lsquo;sorted&rsquo; results</p>

<p>This step is very important to understand. It means two things for the reducer:</p>

<ul>
<li>For each primary key (<code>game_id</code> in our example), all the corresponding lines will be sent to the same reducer instance. This allows to process data without any communication between the reducers.</li>
<li>The data is sorted. This implies that if a reducer sees a <code>game_id=1</code> key, then all following lines will also be <code>game_id=1</code> until there is no <code>game_id=1</code> key left. Ever. As soon a the reducer receives a different primary key, then we can assume <strong>all</strong> the <code>game_id=1</code> lines have been processed.</li>
</ul>


<h4>When running with bash:</h4>

<p>As I said, I should be able to run my code both locally and remotely. Fortunately, we can perform a sort with bash with the <code>sort</code> command.</p>

<p>This trick consists of performing a pure sort on the data. When running locally, we don&rsquo;t have to distribute the data between different instances (which hadoop does) so a sorted data will garanty the two features that we require for our reducer.</p>

<p>running this in bash would yield:</p>

<p><code>cat datain/* | map1.rb | sort</code> =>
<code>ruby
1 game_log  chess
1 player_log  1 1
1 player_log  2 0
2 game_log  go
2 player_log  1 2
2 player_log  2 5
</code></p>

<p>As you can see, the data is now grouped by <code>game_id</code> key. How delightful.</p>

<h4>When running with hadoop:</h4>

<p>Simply perform some cool dance moves while hadoop take care of everything.</p>

<p><img class="center" src="/images/success_dance.gif"></p>

<h3>2.3 first reduce</h3>

<p>The first reducer will accumulate the player scores, in order to determine the players ranks in each played game:
```ruby reduce1.rb</p>

<h1>!/usr/bin/env ruby</h1>

<p>class Reducer</p>

<p>  attr_accessor :key, :game_type</p>

<p>  def initialize(key)</p>

<pre><code>@key = key
@player_scores = Hash.new
</code></pre>

<p>  end</p>

<p>  def accumulate(splitted_line)</p>

<pre><code>if splitted_line[1] == 'game_log' #if the line is of type game_log
  @game_type = splitted_line[2]
else # if the line is of type player_log
  player_id = splitted_line[2]
  player_score = splitted_line[3]

  @player_scores[player_id] = player_score
end
</code></pre>

<p>  end</p>

<p>  def output!</p>

<pre><code>ordered_player_ids.each_with_index do |id,i|
  puts [
    "#{@game_type}|#{id}", # joined to form a new key for the next reducer
    i+1 #the rank (+1 so the first has a rank of 1)
  ].join("\t")
end
</code></pre>

<p>  end</p>

<p>  def ordered_player_ids</p>

<pre><code># this will output a list of player_ids, sorted by their scores
# Note that I'm way too lazy to deal with draws here :D
@player_scores.sort_by{|player,score| score}.reverse.map(&amp;:first)
</code></pre>

<p>  end</p>

<p>end</p>

<p>ARGF.each do |line|
  # split the data
  splitted_line = line.chomp.split(&ldquo;\t&rdquo;).map(&amp;:strip)</p>

<p>  # get the primary key
  new_key = splitted_line.first</p>

<p>  #initialize if required
  @red ||= Reducer.new(new_key)</p>

<p>  # if the key is the same, then continue accumulating
  if new_key == @red.key</p>

<pre><code>@red.accumulate(splitted_line)

# if the key is new, then first output current results, then instanciate a new reducer
# Note that once the result is outputed to STDOUT, we can drop the reducer instance
</code></pre>

<p>  else</p>

<pre><code>@red.output! unless @red.key.nil?
@red = Reducer.new(new_key)
@red.accumulate(splitted_line)
</code></pre>

<p>  end
end
@red.output!
```</p>

<p>Now our process yield <code>cat datain.dat | ./map1.rb | sort | ./reduce1.rb</code> =></p>

<p><code>ruby
chess|1 1
chess|2 2
go|1    2
go|2    1
</code></p>

<p>This could be read as</p>

<ul>
<li><em>player 1 scored one chess game with rank 1</em></li>
<li><em>player 2 scored one chess game with rank 2</em></li>
<li><em>player 1 scored one go game with rank 2</em></li>
<li><em>player 2 scored one go game with rank 1</em></li>
</ul>


<p>Please note something very important here: <strong>The reducer stores almost nothing in memory!</strong>
As you can see in the script, as soon as a game is finished processing, then we can simply output the result and drop our reducer. Nothing has to stay in memory, so you don&rsquo;t need any ram on your workers, even to process billions of games !</p>

<h3>2.4. coffe break !</h3>

<p><img class="center" src="/images/coffe-break.gif"></p>

<p>If you&rsquo;re still reading this then I&rsquo;m sure you deserve it.</p>

<h3>2.5. Second mapper</h3>

<p>Nothing has to be done here, the data is already formated for the next reduce step.</p>

<p>Conceptualy, we can view this step as a map step, where the mapper would be identity.
As a reminder that something is still hapening here, I&rsquo;ll pipe the unix <code>cat</code> command to our workflow. Of course it has no practical purpose.</p>

<p>When running our code with hadoop-stream, we&rsquo;ll declare a <code>map</code> step, with identity mapper ( or we&rsquo;ll simply declare <code>cat</code> to be our mapper script, which is pretty much the same)</p>

<h3>2.6 Last step: averaging the scores</h3>

<p>For the sake of the argument, let&rsquo;s say I wasn&rsquo;t this lazy, and generated much more data, which led to a <code>reduce1</code> output that reads</p>

<p><code>ruby
chess|1 1
chess|1 1
chess|2 1
chess|2 2
go|1    2
chess|1 1
go|1    1
go|1    1
chess|2 2
go|1    1
go|1    2
hide-and-seek|1 8
go|2    1
go|2    1
hide-and-seek|3 2
hide-and-seek|1 8
chess|1 1
hide-and-seek|1 8
chess|1 2
hide-and-seek|3 5
hide-and-seek|3 1
</code></p>

<p>We now have three players, three different games. I also shuffled the results, to emphasis that the reduce step does not necessary provide sorted results.
Actually it does when running our <em>bash workflow</em>, since we&rsquo;re using <code>sort</code> and a single proc. Generally speaking it is not.</p>

<p>Once we run the identity mapper, followed by the sort step, it will again be sorted so we can write our final reducer as follows:</p>

<p>```ruby reduce2.rb</p>

<h1>!/usr/bin/env ruby</h1>

<p>class Reducer</p>

<p>  attr_accessor :key, :game_type, :user_id</p>

<p>  def initialize(key,value)</p>

<pre><code>@key = key

#split the primary key to get user_id and game type:
@game_type,@user_id = key.split("|")

#to perform an on-the-fly average, we only need two variables:
@count = 1
@average = value.to_f
</code></pre>

<p>  end</p>

<p>  #on the fly averaging. We do NOT store the entire array !
  def accumulate(value)</p>

<pre><code>@average  = ( @count.to_f/(@count + 1) * @average ) + (value.to_f / (@count + 1) )
@count += 1
</code></pre>

<p>  end</p>

<p>  # follow the expectations
  def output!</p>

<pre><code>puts [
  @user_id,
  @game_type,
  @average.round(1),
].join("\t")
</code></pre>

<p>  end</p>

<p>end</p>

<p>ARGF.each do |line|
  next if line.chomp.empty?</p>

<p>  # split the data
  new_key,value = line.chomp.split(&ldquo;\t&rdquo;).map(&amp;:strip)</p>

<p>  #initialize if required
  @red ||= Reducer.new(new_key,value)</p>

<p>  # if the key is the same, then continue accumulating
  if new_key == @red.key</p>

<pre><code>@red.accumulate(value)
</code></pre>

<p>  # if the key is new, then first output current results, then instanciate a new reducer
  else</p>

<pre><code>@red.output! 
@red = Reducer.new(new_key,value)
</code></pre>

<p>  end
end
@red.output!
```</p>

<p>If we run our bash process we get <code>cat datain/* | ./map1.rb | sort | ./reduce1.rb | cat | sort | ./reduce2.rb</code> (assuming we have our new dataset):</p>

<p><code>ruby
1 chess 1.2
2 chess 1.7
1 go  1.4
2 go  1.0
1 hide-and-seek 8.0
3 hide-and-seek 2.7
</code></p>

<p>And that&rsquo;s it ! we know knows that the player 1 performed an average rank of 1.2 at chess, and an average rank of 8.0 at hide and seek !</p>

<h2>3. Going heavy</h2>

<p>Like I told you, our script are hadoop-ready. Provided you have an aws-amazon account, running our code can be done very easily:</p>

<ul>
<li>install amazon elastic-mapreduce client and configure it (basically give it your credentials)</li>
<li>run the first map-reduce stage:</li>
</ul>


<p><code>bash elastic_mapreduce_launcher_stage1.sh
elastic-mapreduce \
  --create \
  --name look_mom_big_data \
  --stream \
  --input s3n://yourbucket/data_in \
  --mapper s3n://yourbucket/src/map1.rb \
  --reducer s3n://yourbucket/src/reduce1.rb \
  --output s3n://yourbucket/first_results \
  --log-uri s3://yourbucket/emr-logs/ \
  --region eu-west-1 \
  --instance-type m1.small \
  --num-instances 300
</code></p>

<p>then</p>

<p><code>bash elastic_mapreduce_launcher2.sh
elastic-mapreduce \
  --create \
  --name look_mom_big_data \
  --stream \
  --input s3n://yourbucket/first_results \
  --mapper cat \
  --reducer s3n://yourbucket/src/reduce2.rb \
  --output s3n://yourbucket/output \
  --log-uri s3://yourbucket/emr-logs/ \
  --region eu-west-1 \
  --instance-type m1.small \
  --num-instances 300
</code></p>

<p>Note that I&rsquo;m using two different launchers here. You can also tell your launcher to perform multiple steps by passing them as json. See the elastic-mapreduce doc for that.</p>

<p><em>Wait&hellip; Is it this simple?</em></p>

<p>Yes. This simple.</p>

<h2>Conclusion</h2>

<p>Thanks for reading, you&rsquo;re awesome</p>

<p><img class="center" src="/images/not_impressed.gif"></p>

<p>If this helped you in any way, feel free to drop a comment, correct something, ask a question, or simply let me know this was interesting, thanks !</p>

<p>Please note that this approach can be &mdash; and have been &mdash; used for heavy industrial purposes. You can litterally process billions of rows in no time, with a few lines of code. This is, in my opinion, a tremendous way to prototype and scale your data analysis !</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Building an advanced api option parser for grape]]></title>
    <link href="http://aurelien-herve.com/blog/2014/10/14/advanced-api-option-parser-for-grape/"/>
    <updated>2014-10-14T09:52:35+02:00</updated>
    <id>http://aurelien-herve.com/blog/2014/10/14/advanced-api-option-parser-for-grape</id>
    <content type="html"><![CDATA[<p>When building an elaborated api, you might want your users to pass parameters in order to describe exactly what response they expect from the api.</p>

<p>For instance, it is useful to be able to do something as</p>

<p><code>ruby
GET '/users/:id', {users: {name: true}}  # =&gt; find a user and get his name only
GET '/users/:id', {users: {email: true, name: true}} # =&gt; find a user and get both his name and email
GET '/users/:id', {users: {email: true, name: true, posts: true}, post: {title: true}} # =&gt; find a user and get his name, his email, and all his posts titles
</code>
instead of presenting all of the model&rsquo;s attributes at each api call.</p>

<!-- more -->


<h2>1. Basic grape/entity usage</h2>

<p>At <a href="http://shapter.com">Shapter</a> we use the awesome <a href="https://github.com/intridea/grape">Grape</a> api framework, along with <a href="https://github.com/intridea/grape-entity">grape-entity</a>.</p>

<p>For instance, let&rsquo;s say we wan to build a route that finds and present a user:</p>

<p>```ruby AwesomeApp/entities/user.rb
module AwesomeApp
  module Entities</p>

<pre><code>module User &lt; Grape::Entity
  expose :id
  expose :name
  expose :email
end
</code></pre>

<p>  end
end
```</p>

<p>```ruby api/users.rb
namespace :users do  # prefix routes with &lsquo;users/&rsquo;
  desc &ldquo;get a user&rdquo; # describe your method for the documentation
  params do</p>

<pre><code>requires "user_id", desc: "id of the user" # requires a user_id to be passed
</code></pre>

<p>  end
  get &lsquo;:user_id&rsquo; do  # this will get the params[:user_id] from the url</p>

<pre><code>user = User.find(params[:user_id]) || error!('user not found',404) # find the user
present user, with: AwesomeApp::Entities::User  # use grape-entity to present the model
</code></pre>

<p>  end
end
```</p>

<p>This setup will create a <code>/users/:id/</code> route that returns a user in a hash of the form <code>{id: 123, name: "John Doe", email: "foo@bar.com"}</code></p>

<h2>2. With a bit of optimization</h2>

<p>If your api is to grow more complex, the number of exposed attributes can quickly increase, and with it the size of the json hash the api sends. However you do not want all of the <code>User</code>&rsquo;s attributes to be return each time you call your route.</p>

<p>To avoid unnecessary overload, you can build an option parser that allow the api-user to describe the type of response he&rsquo;s expecting.</p>

<h4>Add conditional exposures to your entity</h4>

<p>First we tell entity to expose attributes only when asked to:</p>

<p>```ruby AwesomeApp/entities/user.rb
module AwesomeApp
  module Entities</p>

<pre><code>module User &lt; Grape::Entity
  expose :id # always expose the id
  expose :name, if: lambda{ |user,options| options[:entity_options]["user"][:name]}   #conditional exposure
  expose :email, if: lambda{ |user,options| options[:entity_options]["user"][:email]} #conditional exposure
end
</code></pre>

<p>  end
end
```</p>

<h4>create a helper to parse the options</h4>

<p>Next, we create a helper that will read <code>params</code> to avoid tedious code duplication:</p>

<p>```ruby AwesomeApp/Helpers/OptionsHelper</p>

<h1>white-list params[:entities][&lt;some_model>], and create empty hashes if needed:</h1>

<p>def entity_options
  {</p>

<pre><code>"user" =&gt; (params[:entities]["user"] rescue nil) || {},
"post" =&gt; (params[:entities]["post"] rescue nil) || {},
</code></pre>

<p>  }
end
```</p>

<h4>pass the options hash to Grape::Entity</h4>

<p>Finally, we need to connect everything in the api method description:</p>

<p>```ruby api/users.rb
helpers AwesomeApp::Helpers::OptionsHelper #include the helper</p>

<p>namespace :users do</p>

<pre><code>...
present user, with: AwesomeApp::Entities::User, entity_options: entity_options #simple call entity_options
</code></pre>

<p>end
```</p>

<h4>Profit</h4>

<p>And <em>Voila</em> !</p>

<p>Now your api-users can efficiently call the routes to get the attributes they want:
<code>ruby
GET '/users/:id', {users: {name: true}}  # =&gt; find a user and get his name only
GET '/users/:id', {users: {email: true, name: true}} # =&gt; find a user and get both his name and email
</code></p>

<h3>Bonus: it works with nested model exposures !</h3>

<p>Note that this system supports nested models exposures. For instance, if you want to get a user, and a list of his post ids and titles, then the following will work like a charm:</p>

<p>```ruby AwesomeApp/entities/user.rb</p>

<h1>AwesomeApp/entities/user.rb</h1>

<p>module AwesomeApp
  module Entities</p>

<pre><code>module User &lt; Grape::Entity
  expose :id # always expose the id
  expose :name, if: lambda{ |user,options| options[:entity_options]["user"][:name]}   #conditional exposure
  expose :email, if: lambda{ |user,options| options[:entity_options]["user"][:email]} #conditional exposure
  expose :posts, using: AwesomeApp::Entities::Post, if: lambda{ |user,options| options[:entity_options]["user"][:posts]} # present user's posts
end
</code></pre>

<p>  end
end</p>

<h1>AwesomeApp/Entities/post.rb</h1>

<p>module AwesomeApp
  module Entities</p>

<pre><code>module Post &lt; Grape::Entity
  expose :id # always expose the id
  expose :title, if: lambda{ |post,options| options[:entity_options]["post"][:name]}   #conditional exposure
  expose :content, if: lambda{ |post,options| options[:entity_options]["post"][:email]} #conditional exposure
end
</code></pre>

<p>  end
end
```</p>

<p>Without changing anything to the api, you can now call
<code>ruby
GET '/users/123', entity_options: { user: {name: true, posts: true}, post: {title: true}}
</code>
To tell the api you want to include the user&rsquo;s post ids in the response. You will then get something that looks like
```
{
  id: 123,
  name: &ldquo;John Doe&rdquo;,
  posts: [</p>

<pre><code>{id: 456, title: "first post" }, #post content is not asked for, therefore not sent
{id: 789, title: "second post" },
</code></pre>

<p>  ]
}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Having fun with functional programming in ruby]]></title>
    <link href="http://aurelien-herve.com/blog/2014/02/27/some-cool-functional-programming-with-ruby/"/>
    <updated>2014-02-27T21:51:46+01:00</updated>
    <id>http://aurelien-herve.com/blog/2014/02/27/some-cool-functional-programming-with-ruby</id>
    <content type="html"><![CDATA[<p>Today we&rsquo;re going to play around with functional programming. Yay !</p>

<ul>
<li><em>Ok, what&rsquo;s that exactly ?</em></li>
</ul>


<p>Wikipedia says it pretty much:</p>

<blockquote><p>functional programming is a programming paradigm, a style of building the structure and elements of computer programs, that treats computation as the evaluation of mathematical functions and avoids state and mutable data.</p></blockquote>

<ul>
<li>Alright, now let&rsquo;s have some fun with functional programming style, and of course, let&rsquo;s do that with ruby :)</li>
</ul>


<p>In this post we&rsquo;re going to manipulate some (high order) functions, and build a derivative operator in a functional style.</p>

<!-- more -->


<h3>Level 1 : some basic functions</h3>

<p>In ruby you can define a <em>lambda</em> operator, that is an anonymous function that reads exactly as a mathematician would define it. For instance,
<code>ruby
square = -&gt; x { x*x} #or its equivalent notation: square = lambda { |x| x*x }
plus_one = -&gt; x { x+1}
</code>
defines a function that, when given an argument <code>x</code>, returns <code>x*x</code>.</p>

<p>We can call it and see the result :
<code>ruby
square.(2) #=&gt; 4
plus_one.(2) #=&gt; 3
</code></p>

<p>More interestingly, higher order function can be defined, whose purpose is to manipulate other functions.</p>

<p>For instance, let&rsquo;s define some basic operators <code>minus</code>,<code>mult</code>,<code>div</code> that can respectively add, subtract, multiply or divide functions altogether.</p>

<p>Note that we want <code>new_function = minus.(f,g)</code> to return a function.
Rather than describing how to subtract two values, we want to define what <code>f -g</code> means when both f and g are functions.</p>

<p><code>ruby
minus = -&gt; f,g { -&gt; x { f.(x) - g.(x) } }
div   = -&gt; f,g { -&gt; x { f.(x) / g.(x) } }
mult  = -&gt; f,g { -&gt; x { f.(x) * g.(x) } }
</code></p>

<p>Does that works ? With the previously defined functions:</p>

<p><code>ruby
my_fancy_func = minus.(square,plus_one) # defining a new function
my_fancy_func.(3) #=&gt; 5 = 3*3 - ( 3 + 1)
</code></p>

<p>Sweet.</p>

<ul>
<li><em>Allright, but how is that really fancy?</em></li>
</ul>


<p>Well, let&rsquo;s take our trip to a next step:</p>

<h3>Level 2 : I can haz derivative ?</h3>

<p><em>Hey, I know an operator that works on functions : the derivative operator. How about we build one ?</em></p>

<p>Alright. Let&rsquo;s build a derivative operator. That is, a function that takes a function as an argument, and return another function: its derivate.</p>

<p>The derivative of a function at some point <em>x</em> can be obtained by evaluating
<img src="/images/derivative.gif" alt="derivative" />, <em>i.e.</em> the limit when epsilon &ndash;> 0 of a derivative scheme based on f at point x.</p>

<p>Here&rsquo;s the plan :</p>

<ul>
<li>Define a limit operator</li>
<li>define a derivative scheme</li>
<li>define the derivative operator as the limit of the derivative scheme of a function</li>
<li>Since we&rsquo;re at it, define any <em>nth derivative operator</em> : We should be able to derivate n times any function.</li>
<li>Profit and use it on <em>any function</em></li>
</ul>


<p>For the sake of clarity, let&rsquo;s begin with a simplified version, and assume that <code>epsilon = 1e-3</code> is low enough to approximate the limit of our derivative scheme.</p>

<p>Once we&rsquo;re more comfortable with the concepts, we&rsquo;ll get rid of this assumption and implement a true derivative operator.</p>

<p>```ruby
derivative = &ndash;> f { # we take a function as argument
  &ndash;> x { # the function takes a real x as argument</p>

<pre><code>( f.(x+1e-3) - f.(x-1e-3) ) / ( 2e-3 ) # apply the scheme
</code></pre>

<p>  }
}</p>

<h1>Let&rsquo;s try:</h1>

<p>derivative_of_square = derivative.(square)  => #&lt;Proc:0x00000001b7c270@(irb):24 (lambda)> . Yay, a new function !</p>

<h1>Can we use it ?</h1>

<p>square.(3) # => 9
derivative_of_square.(3) #  => 5.999999999999339 ~ 2*3. Cool !
```</p>

<p><em>Sooo&hellip; can I derivate twice ?</em></p>

<p>Yup. Simply get the derivative of the derivative :
<code>ruby
second_derivative_of_square = derivative.( derivative.(square) ) # this should be a constant function that return 2
second_derivative_of_square.(2) #=&gt; 1.999999999946489
second_derivative_of_square.(3) #=&gt; 2.000000000279556
</code></p>

<p><em>Sooooooo&hellip; can I derivate n times ?</em></p>

<p>Yup. Although we don&rsquo;t want to create thousands of <code>third_derivative</code>,<code>forth_derivative</code>&hellip;etc, right ?</p>

<p>Let&rsquo;s go one order higher and define the <em>nth derivative operator</em></p>

<p>Since we can derivate a function, and we want to do it n times, what we miss is simply a <code>n-times combinator</code>. For example, <code>n_times.(f).(2)</code> should return <code>x -&gt; f(f(x))</code> regardless of what <code>f</code> and <code>x</code> are.</p>

<p>Shall we do it recursively ?
<code>ruby
n_times = -&gt; n,f {
  n == 1 ? f : -&gt; x { f.(n_times.(n-1,f).(x))}
}
</code></p>

<p><strong>Explanation</strong> :</p>

<ul>
<li>if <em>n = 1</em> then we want f. so return f. So far so good, <code>n_times(1,f) = f</code></li>
<li>If <em>n = 2</em>, then we want f(f) = f( n_times.(1,f) )</li>
<li>If <em>n = 3</em>, then we want f(f(f)) = f( n_times.(2,f) )</li>
</ul>


<p>&hellip;etc. Get it ?</p>

<p><em>Wait&hellip; that&rsquo;s all ? Where&rsquo;s my nth derivative ?</em></p>

<p>Now it&rsquo;s quite easy to derivate n times :</p>

<p><code>ruby
nth_derivator = -&gt; n {
  n_times.(n,derivate)
}
</code>
This <code>nth_derivator</code> will take <code>n</code> as an argument, and derivate n times whatever we decide to pass to it.</p>

<p>Let&rsquo;s play with it!
```ruby
derivative_of_square = nth_derivator.(1).(square) #derivate one time
second_derivative_of_square = nth_derivator.(2).(square) #derivate two times
third_derivative_of_square = nth_derivator.(3).(square) #derivate three times</p>

<p>p derivative_of_square.(3) # => 5.999999999999339
p second_derivative_of_square.(3) # => 2.000000000279556
p third_derivative_of_square.(3) # => 0.0
```</p>

<p><em>That&rsquo;s cool ! but those are approximations, right ? we never actually calculated the limit</em></p>

<p>Yet.</p>

<h3>Level 3 : More functional, and a true limit operator</h3>

<p>Now that we have a better feel for it (have we?), let&rsquo;s refactor our derivative operator so that it is <em>actually</em> defined as a limit. And hey, let&rsquo;s parametrize the precision that we want since we&rsquo;re at it.</p>

<p><img class="right" src="/images/party_over.gif" title="" ></p>

<p>First, let&rsquo;s write a bunch of tools that are going to be useful:
```ruby
minus = &ndash;> f,g { &ndash;> x { f.(x) &ndash; g.(x) } } # f &ndash; g
div   = &ndash;> f,g { &ndash;> x { f.(x) / g.(x) } } # f / g
mult  = &ndash;> f,g { &ndash;> x { f.(x) * g.(x) } } # f * g
norm  = &ndash;> f   { &ndash;> x { f.(x).abs}} # absolute value
const = &ndash;> const { &ndash;> x { const} } # That&rsquo;s right, the constant function !</p>

<h1>You should recognize these:</h1>

<p>plus_eps = &ndash;> eps { &ndash;> f { &ndash;> x { f.(x+eps) } } }
min_eps  = &ndash;> eps { &ndash;> f { &ndash;> x { f.(x-eps) } } }</p>

<h1>is f &lt; g ?</h1>

<p>inf = &ndash;> f,g { &ndash;> x { f.(x) &lt; g.(x) } }
```</p>

<p>Now the limit function. Here we are going to define a function, that actually implement the following (naive) algorithm:</p>

<ul>
<li>variables : a function <code>f</code>, a starting epsilon <code>eps</code>, and a threshold <code>tres</code></li>
<li><ol>
<li>Evaluate y = ||f(x + epsilon/2) &ndash; f(x + epsilon) ||</li>
</ol>
</li>
<li><ol>
<li>if y &lt; tres, then we are converged, and lowering epsilon wouldn&rsquo;t change the result much. Return f(x+epsilon).</li>
</ol>
</li>
<li><ol>
<li>else, reduce epsilon and try again (i.e. go to 1.)</li>
</ol>
</li>
</ul>


<p>Obviously, this algorithm is quite simple, and will only work when dealing with smooth, continuous, and gracious functions.</p>

<p>Ready ?
```ruby
lim = &ndash;> f,eps,tres {
  &ndash;> x {</p>

<pre><code>inf.(
  norm.(
    minus.(
      plus_eps.(eps/2.0).(f),
      plus_eps.(eps).(f)
    )
  ), const.(tres) ).(x) ? plus_eps.(eps).(f).(x) : lim.(f,eps/2.0,tres).(x)
</code></pre>

<p>  }
}</p>

<h1>Does it even work ?</h1>

<p>lim.(square,1,1).(2) #=> 5.0625 wut ?
lim.(square,1,1e-2).(2) #=> 4.0156402587890625 Ah. Better
lim.(square,1,1e-16).(2) #=> 4.0 How nice !
```</p>

<p>Now we&rsquo;re getting close ! Let&rsquo;s refactor our derivative operator in a more appropriate way and get our final derivative operator:</p>

<p>```ruby</p>

<h1>derivative_scheme.(f).(x) shall be a function of epsilon</h1>

<p>derivative_sheme = &ndash;> f {
  &ndash;> x {</p>

<pre><code>-&gt; eps {
  div.( minus.(plus_eps.(eps).(f), min_eps.(eps).(f) ), mult.(const.(2), const.(eps))).(x)
}
</code></pre>

<p>  }
}</p>

<h1>And the derivative operator:</h1>

<h1>Let&rsquo;s fix the treshold at tres = 1e-16</h1>

<p>derivate = &ndash;> f {
  &ndash;> x {</p>

<pre><code>lim.(derivative_sheme.(f).(x),1,1e-16).(0) # limit of the derivative scheme of f(x), taken at epsilon = 0
</code></pre>

<p>  }
}</p>

<h1>Isn&rsquo;t that fancy ? We juste define the derivative operator</h1>

<h1>exactly as the limit of (f(x + e) &ndash; f(x &ndash; e))/(2e) when epsilon &ndash;> 0</h1>

<p>```</p>

<h3>Summary</h3>

<p>Here&rsquo;s a full code of what we implemented <a href="/assets/aherves_blog_ruby_functional.rb">(download it)</a></p>

<p>```ruby</p>

<h1>!/usr/bin/env ruby</h1>

<h1>Our fancy function. Could be exactly anything</h1>

<p>square = &ndash;> x { x*x}</p>

<h1>some tools</h1>

<p>minus = &ndash;> f,g { &ndash;> x { f.(x) &ndash; g.(x) } }
div   = &ndash;> f,g { &ndash;> x { f.(x) / g.(x) } }
mult  = &ndash;> f,g { &ndash;> x { f.(x) * g.(x) } }
norm  = &ndash;> f   { &ndash;> x { f.(x).abs}}
const = &ndash;> const { &ndash;> x { const} }</p>

<p>plus_eps = &ndash;> eps { &ndash;> f { &ndash;> x { f.(x+eps) } } }
min_eps  = &ndash;> eps { &ndash;> f { &ndash;> x { f.(x-eps) } } }</p>

<p>inf = &ndash;> f,g { &ndash;> x { f.(x) &lt; g.(x) } }</p>

<h1>The limit operator</h1>

<p>lim = &ndash;> f,eps,prec {
   &ndash;> x {</p>

<pre><code>inf.(norm.(minus.(plus_eps.(eps/2.0).(f), plus_eps.(eps).(f))) , const.(prec) ).(x) ? plus_eps.(eps).(f).(x) : lim.(f,eps/2.0,prec).(x)
</code></pre>

<p>  }
}</p>

<h1>The derivative scheme</h1>

<p>derivative_sheme = &ndash;> f {
  &ndash;> x {
  &ndash;> eps {
  div.( minus.(plus_eps.(eps).(f), min_eps.(eps).(f) ), mult.(const.(2), const.(eps))).(x)
}
}
}</p>

<h1>The derivative operator at precision 1e-16 is the limit of the derivative scheme</h1>

<p>derivate = &ndash;> f{
  &ndash;> x {
  lim.(derivative_sheme.(f).(x),1,1e-16).(0)
}
}</p>

<h1>call any function n times</h1>

<p>n_times = &ndash;> n,f {
  n == 1 ? f : &ndash;> x { f.(n_times.(n-1,f).(x))}
}</p>

<h1>an nth derivator is a derivator called n times:</h1>

<p>nth_derivator = &ndash;> n {
  n_times.(n,derivate)
}</p>

<p>p nth_derivator.(1).(square).(3) # => 6 =  2*(3)
p nth_derivator.(2).(square).(3) # => 2 =  constant(2)
p nth_derivator.(3).(square).(3) # => 0 = constant(0)</p>

<p>logarithm = &ndash;> x { Math.log(x) }
p nth_derivator.(1).(logarithm).(3) #=> 0.3333333333430346 ~ 1/3 I can derivate whatever I want !
```</p>

<p>Well that&rsquo;s all, hope you enjoyed reading this (at least) as much as I enjoyed writing it. Feel free to drop some comments, suggest anything, c orrect some code (or my english ) :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to create a gem structure with rspec and code coverage]]></title>
    <link href="http://aurelien-herve.com/blog/2014/02/15/create-a-gem-structure-with-rspec-and-code-coverage/"/>
    <updated>2014-02-15T21:59:36+01:00</updated>
    <id>http://aurelien-herve.com/blog/2014/02/15/create-a-gem-structure-with-rspec-and-code-coverage</id>
    <content type="html"><![CDATA[<h3>tl;dr</h3>

<p>This is a step-by-step tutorial for creating a gem structure, along with some unit tests and code coverage.</p>

<!-- more -->


<h2>1. Bundle: create the structure</h2>

<ul>
<li>Create the directories using bundler:
<code>
$ bundle gem my_fancy_gem
create  my_fancy_gem/Gemfile
create  my_fancy_gem/Rakefile
create  my_fancy_gem/LICENSE.txt
create  my_fancy_gem/README.md
create  my_fancy_gem/.gitignore
create  my_fancy_gem/my_fancy_gem.gemspec
create  my_fancy_gem/lib/my_fancy_gem.rb
create  my_fancy_gem/lib/my_fancy_gem/version.rb
Initializing git repo in &lt;wherever you are&gt;/my_fancy_gem
</code></li>
<li>fill the gem description in <code>my_fancy_gem.gemspec</code></li>
</ul>


<h2>2. Configure rspec</h2>

<ul>
<li><p>add rspec to the dependencies in <code>my_fancy_gem.gemspec</code>:
<code>ruby my_fancy_gem.gemspec
...
spec.add_development_dependency "rake"
spec.add_development_dependency "rspec"
end
</code>
and make sure you install it:
  $ bundle</p></li>
<li><p>create <code>spec/spec_helper.rb</code> file:
<code>ruby spec/spec_helper.rb
require 'rspec'
require 'my_fancy_gem'
</code></p></li>
<li><p>I like it better with colors. In <code>.rspec</code>:
<code>ruby .rspec
--color
</code></p></li>
</ul>


<h3>Now let&rsquo;s create some method and test it</h3>

<p>Let&rsquo;s write a hello world method with TDD</p>

<ul>
<li>in <code>spec/my_fancy_gem_spec.rb</code>
<code>ruby spec/my_fancy_gem_spec.rb
require 'spec_helper'
describe SmartadCollector do
it "should greet" do
  SmartadCollector::greet.should == "Hello, world!"
end
end
</code></li>
<li>Proudly watch the test failing by running <code>rspec</code></li>
<li>Now let&rsquo;s write the actual method: <code>lib/my_fancy_gem_spec.rb</code>
```ruby lib/my_fancy_gem.rb
require &ldquo;my_fancy_gem/version&rdquo;</li>
</ul>


<p>module MyFancyGem
  def self.greet</p>

<pre><code>"Hello, world!"
</code></pre>

<p>  end
end
```
and (even more) proudly watch the test pass:</p>

<pre><code>$ rspec #=&gt; 1 example, 0 failures
</code></pre>

<h2>3. Adding code coverage tools</h2>

<p><a href="https://github.com/colszowka/simplecov">SimpleCov</a> to get code coverage:</p>

<ul>
<li>add <code>spec.add_development_dependency "simplecov"</code> in <code>my_fancy_gem_spec.gemspec</code>.</li>
<li><p><code>$ bundle install</code> to install the simple cov gem</p></li>
<li><p>create a <code>.simplecov</code> file:
<code>ruby .simplecov
SimpleCov.start do
add_group "lib", "lib"
end
</code></p></li>
<li><p>add it to rspec: <code>spec/spec_helper.rb</code>:
<code>ruby spec/spec_helper.rb
require 'rspec'
require 'simplecov'
require 'my_fancy_gem_spec'
</code>
Please note that the <code>require 'simplecov'</code> has to be added before <code>require 'my_fancy_gem_spec'</code>.</p></li>
</ul>


<p>Now running <code>$ rspec</code> will output a report on code coverage, as well as a <code>coverage</code> directory. You can browse <code>coverage/index.html</code> to view the detailed report.</p>
]]></content>
  </entry>
  
</feed>
